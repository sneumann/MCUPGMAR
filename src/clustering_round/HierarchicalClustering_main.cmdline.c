/*
  File autogenerated by gengetopt version 2.19.1
  generated with the following command:
  gengetopt -i HierarchicalClustering_main.ggo -F HierarchicalClustering_main.cmdline 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "HierarchicalClustering_main.cmdline.h"

const char *gengetopt_args_info_purpose = "MC-UPGMA - Accurate huge scale clustering by Memory Constrained UPGMA. Provide \npart of the complete accurate hierarchical clustering solution (tree), by \nreading only part of the edges into memory as dictated by an explicit memory \nconstraint M. The input is a sparse graph of non-negative cluster distances, or \ndissimilarities, as scores are allowed to be non-metric. In the first run, \ndissimilarities between single data items (singleton clusters) are given. \nMissing edges in the sparse graph are assumed to be equal \\psi (the \nmax-distance command line argument) for the purpose of computing average \ncluster distances. Average cluster dissimilarities are required as input to \ncontinue clustering, and are computed by external programs to this program.\n\nIf you find this code useful, please cite:\nLoewenstein Y, Portugaly E, Fromer M, Linial M.\nEfficient algorithms for accurate hierarchical clustering of huge datasets: \ntackling the entire protein space.\nBioinformatics. 2008 Jul 1;24(13):i41-9.\n";

const char *gengetopt_args_info_usage = "Usage: hierarchical_clustering (MC-UPGMA) [OPTIONS]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help                    Print help and exit",
  "  -V, --version                 Print version and exit",
  "  -d, --max-distance=FLOAT      Max possible distance between two singletons \n                                  (\\psi). Used for missing edges when \n                                  averaging across clusters. ",
  "  -n, --max-cluster-index=INT   Index of the last singleton (may be more than \n                                  that)",
  "  -M, --number-of-input-edges=INT\n                                Memory constraint - maximum number of edges to \n                                  load from input",
  "  -a, --average-type=STRING     {arithmetic, geometric, minimum, maximum} - the \n                                  clustering objective (e.g. average-linkage, \n                                  complete-linkage etc.).  \n                                  (default=`arithmetic')",
  "  -i, --input-cluster-edges-file=STRING\n                                Cluster (or singleton) edges (format: cluster1 \n                                  cluster2 distance)  (default=`-')",
  "  -o, --output-merges-file-name=STRING\n                                Output merges file  (default=`-')",
  "      --input-cluster-sizes-file-name=STRING\n                                Initial size of each input cluster (singleton \n                                  size)",
  "      --output-cluster-sizes-file-name=STRING\n                                End size of each output cluster (cluster size)",
  "      --allow-non-dendrogram    Allows merging of provably minimal edge \n                                  intervals, even if the exact merge score \n                                  (cluster height in dendrogram) is not known \n                                  at merge time due to partial knowledge \n                                  implied by the memory constraint. This option \n                                  allows further clustering per round, thus \n                                  speeding up the wholse clustering process \n                                  considerably, by posing a less strict \n                                  requirement on the output - now the cluster \n                                  heights are no longer required to be exact. \n                                  Currently, an upper bound on the merge score \n                                  is output in this case.  (default=off)",
    0
};

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->max_distance_given = 0 ;
  args_info->max_cluster_index_given = 0 ;
  args_info->number_of_input_edges_given = 0 ;
  args_info->average_type_given = 0 ;
  args_info->input_cluster_edges_file_given = 0 ;
  args_info->output_merges_file_name_given = 0 ;
  args_info->input_cluster_sizes_file_name_given = 0 ;
  args_info->output_cluster_sizes_file_name_given = 0 ;
  args_info->allow_non_dendrogram_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->max_distance_orig = NULL;
  args_info->max_cluster_index_orig = NULL;
  args_info->number_of_input_edges_orig = NULL;
  args_info->average_type_arg = gengetopt_strdup ("arithmetic");
  args_info->average_type_orig = NULL;
  args_info->input_cluster_edges_file_arg = gengetopt_strdup ("-");
  args_info->input_cluster_edges_file_orig = NULL;
  args_info->output_merges_file_name_arg = gengetopt_strdup ("-");
  args_info->output_merges_file_name_orig = NULL;
  args_info->input_cluster_sizes_file_name_arg = NULL;
  args_info->input_cluster_sizes_file_name_orig = NULL;
  args_info->output_cluster_sizes_file_name_arg = NULL;
  args_info->output_cluster_sizes_file_name_orig = NULL;
  args_info->allow_non_dendrogram_flag = 0;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->max_distance_help = gengetopt_args_info_help[2] ;
  args_info->max_cluster_index_help = gengetopt_args_info_help[3] ;
  args_info->number_of_input_edges_help = gengetopt_args_info_help[4] ;
  args_info->average_type_help = gengetopt_args_info_help[5] ;
  args_info->input_cluster_edges_file_help = gengetopt_args_info_help[6] ;
  args_info->output_merges_file_name_help = gengetopt_args_info_help[7] ;
  args_info->input_cluster_sizes_file_name_help = gengetopt_args_info_help[8] ;
  args_info->output_cluster_sizes_file_name_help = gengetopt_args_info_help[9] ;
  args_info->allow_non_dendrogram_help = gengetopt_args_info_help[10] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n", CMDLINE_PARSER_PACKAGE, CMDLINE_PARSER_VERSION);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  printf("\n%s\n\n", gengetopt_args_info_usage);

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);

  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  
  if (args_info->max_distance_orig)
    {
      free (args_info->max_distance_orig); /* free previous argument */
      args_info->max_distance_orig = 0;
    }
  if (args_info->max_cluster_index_orig)
    {
      free (args_info->max_cluster_index_orig); /* free previous argument */
      args_info->max_cluster_index_orig = 0;
    }
  if (args_info->number_of_input_edges_orig)
    {
      free (args_info->number_of_input_edges_orig); /* free previous argument */
      args_info->number_of_input_edges_orig = 0;
    }
  if (args_info->average_type_arg)
    {
      free (args_info->average_type_arg); /* free previous argument */
      args_info->average_type_arg = 0;
    }
  if (args_info->average_type_orig)
    {
      free (args_info->average_type_orig); /* free previous argument */
      args_info->average_type_orig = 0;
    }
  if (args_info->input_cluster_edges_file_arg)
    {
      free (args_info->input_cluster_edges_file_arg); /* free previous argument */
      args_info->input_cluster_edges_file_arg = 0;
    }
  if (args_info->input_cluster_edges_file_orig)
    {
      free (args_info->input_cluster_edges_file_orig); /* free previous argument */
      args_info->input_cluster_edges_file_orig = 0;
    }
  if (args_info->output_merges_file_name_arg)
    {
      free (args_info->output_merges_file_name_arg); /* free previous argument */
      args_info->output_merges_file_name_arg = 0;
    }
  if (args_info->output_merges_file_name_orig)
    {
      free (args_info->output_merges_file_name_orig); /* free previous argument */
      args_info->output_merges_file_name_orig = 0;
    }
  if (args_info->input_cluster_sizes_file_name_arg)
    {
      free (args_info->input_cluster_sizes_file_name_arg); /* free previous argument */
      args_info->input_cluster_sizes_file_name_arg = 0;
    }
  if (args_info->input_cluster_sizes_file_name_orig)
    {
      free (args_info->input_cluster_sizes_file_name_orig); /* free previous argument */
      args_info->input_cluster_sizes_file_name_orig = 0;
    }
  if (args_info->output_cluster_sizes_file_name_arg)
    {
      free (args_info->output_cluster_sizes_file_name_arg); /* free previous argument */
      args_info->output_cluster_sizes_file_name_arg = 0;
    }
  if (args_info->output_cluster_sizes_file_name_orig)
    {
      free (args_info->output_cluster_sizes_file_name_orig); /* free previous argument */
      args_info->output_cluster_sizes_file_name_orig = 0;
    }
  
  clear_given (args_info);
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  if (args_info->help_given) {
    fprintf(outfile, "%s\n", "help");
  }
  if (args_info->version_given) {
    fprintf(outfile, "%s\n", "version");
  }
  if (args_info->max_distance_given) {
    if (args_info->max_distance_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "max-distance", args_info->max_distance_orig);
    } else {
      fprintf(outfile, "%s\n", "max-distance");
    }
  }
  if (args_info->max_cluster_index_given) {
    if (args_info->max_cluster_index_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "max-cluster-index", args_info->max_cluster_index_orig);
    } else {
      fprintf(outfile, "%s\n", "max-cluster-index");
    }
  }
  if (args_info->number_of_input_edges_given) {
    if (args_info->number_of_input_edges_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "number-of-input-edges", args_info->number_of_input_edges_orig);
    } else {
      fprintf(outfile, "%s\n", "number-of-input-edges");
    }
  }
  if (args_info->average_type_given) {
    if (args_info->average_type_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "average-type", args_info->average_type_orig);
    } else {
      fprintf(outfile, "%s\n", "average-type");
    }
  }
  if (args_info->input_cluster_edges_file_given) {
    if (args_info->input_cluster_edges_file_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "input-cluster-edges-file", args_info->input_cluster_edges_file_orig);
    } else {
      fprintf(outfile, "%s\n", "input-cluster-edges-file");
    }
  }
  if (args_info->output_merges_file_name_given) {
    if (args_info->output_merges_file_name_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "output-merges-file-name", args_info->output_merges_file_name_orig);
    } else {
      fprintf(outfile, "%s\n", "output-merges-file-name");
    }
  }
  if (args_info->input_cluster_sizes_file_name_given) {
    if (args_info->input_cluster_sizes_file_name_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "input-cluster-sizes-file-name", args_info->input_cluster_sizes_file_name_orig);
    } else {
      fprintf(outfile, "%s\n", "input-cluster-sizes-file-name");
    }
  }
  if (args_info->output_cluster_sizes_file_name_given) {
    if (args_info->output_cluster_sizes_file_name_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "output-cluster-sizes-file-name", args_info->output_cluster_sizes_file_name_orig);
    } else {
      fprintf(outfile, "%s\n", "output-cluster-sizes-file-name");
    }
  }
  if (args_info->allow_non_dendrogram_given) {
    fprintf(outfile, "%s\n", "allow-non-dendrogram");
  }
  
  fclose (outfile);

  i = EXIT_SUCCESS;
  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}


/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;

  result = cmdline_parser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, NULL) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error = 0;

  /* checks for required options */
  if (! args_info->max_distance_given)
    {
      fprintf (stderr, "%s: '--max-distance' ('-d') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (! args_info->max_cluster_index_given)
    {
      fprintf (stderr, "%s: '--max-cluster-index' ('-n') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (! args_info->number_of_input_edges_given)
    {
      fprintf (stderr, "%s: '--number-of-input-edges' ('-M') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  
  /* checks for dependences among options */

  return error;
}

int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "max-distance",	1, NULL, 'd' },
        { "max-cluster-index",	1, NULL, 'n' },
        { "number-of-input-edges",	1, NULL, 'M' },
        { "average-type",	1, NULL, 'a' },
        { "input-cluster-edges-file",	1, NULL, 'i' },
        { "output-merges-file-name",	1, NULL, 'o' },
        { "input-cluster-sizes-file-name",	1, NULL, 0 },
        { "output-cluster-sizes-file-name",	1, NULL, 0 },
        { "allow-non-dendrogram",	0, NULL, 0 },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hVd:n:M:a:i:o:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'd':	/* Max possible distance between two singletons (\\psi). Used for missing edges when averaging across clusters. .  */
          if (local_args_info.max_distance_given)
            {
              fprintf (stderr, "%s: `--max-distance' (`-d') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->max_distance_given && ! override)
            continue;
          local_args_info.max_distance_given = 1;
          args_info->max_distance_given = 1;
          args_info->max_distance_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->max_distance_orig)
            free (args_info->max_distance_orig); /* free previous string */
          args_info->max_distance_orig = gengetopt_strdup (optarg);
          break;

        case 'n':	/* Index of the last singleton (may be more than that).  */
          if (local_args_info.max_cluster_index_given)
            {
              fprintf (stderr, "%s: `--max-cluster-index' (`-n') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->max_cluster_index_given && ! override)
            continue;
          local_args_info.max_cluster_index_given = 1;
          args_info->max_cluster_index_given = 1;
          args_info->max_cluster_index_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->max_cluster_index_orig)
            free (args_info->max_cluster_index_orig); /* free previous string */
          args_info->max_cluster_index_orig = gengetopt_strdup (optarg);
          break;

        case 'M':	/* Memory constraint - maximum number of edges to load from input.  */
          if (local_args_info.number_of_input_edges_given)
            {
              fprintf (stderr, "%s: `--number-of-input-edges' (`-M') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->number_of_input_edges_given && ! override)
            continue;
          local_args_info.number_of_input_edges_given = 1;
          args_info->number_of_input_edges_given = 1;
          args_info->number_of_input_edges_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->number_of_input_edges_orig)
            free (args_info->number_of_input_edges_orig); /* free previous string */
          args_info->number_of_input_edges_orig = gengetopt_strdup (optarg);
          break;

        case 'a':	/* {arithmetic, geometric, minimum, maximum} - the clustering objective (e.g. average-linkage, complete-linkage etc.)..  */
          if (local_args_info.average_type_given)
            {
              fprintf (stderr, "%s: `--average-type' (`-a') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->average_type_given && ! override)
            continue;
          local_args_info.average_type_given = 1;
          args_info->average_type_given = 1;
          if (args_info->average_type_arg)
            free (args_info->average_type_arg); /* free previous string */
          args_info->average_type_arg = gengetopt_strdup (optarg);
          if (args_info->average_type_orig)
            free (args_info->average_type_orig); /* free previous string */
          args_info->average_type_orig = gengetopt_strdup (optarg);
          break;

        case 'i':	/* Cluster (or singleton) edges (format: cluster1 cluster2 distance).  */
          if (local_args_info.input_cluster_edges_file_given)
            {
              fprintf (stderr, "%s: `--input-cluster-edges-file' (`-i') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->input_cluster_edges_file_given && ! override)
            continue;
          local_args_info.input_cluster_edges_file_given = 1;
          args_info->input_cluster_edges_file_given = 1;
          if (args_info->input_cluster_edges_file_arg)
            free (args_info->input_cluster_edges_file_arg); /* free previous string */
          args_info->input_cluster_edges_file_arg = gengetopt_strdup (optarg);
          if (args_info->input_cluster_edges_file_orig)
            free (args_info->input_cluster_edges_file_orig); /* free previous string */
          args_info->input_cluster_edges_file_orig = gengetopt_strdup (optarg);
          break;

        case 'o':	/* Output merges file.  */
          if (local_args_info.output_merges_file_name_given)
            {
              fprintf (stderr, "%s: `--output-merges-file-name' (`-o') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->output_merges_file_name_given && ! override)
            continue;
          local_args_info.output_merges_file_name_given = 1;
          args_info->output_merges_file_name_given = 1;
          if (args_info->output_merges_file_name_arg)
            free (args_info->output_merges_file_name_arg); /* free previous string */
          args_info->output_merges_file_name_arg = gengetopt_strdup (optarg);
          if (args_info->output_merges_file_name_orig)
            free (args_info->output_merges_file_name_orig); /* free previous string */
          args_info->output_merges_file_name_orig = gengetopt_strdup (optarg);
          break;


        case 0:	/* Long option with no short option */
          /* Initial size of each input cluster (singleton size).  */
          if (strcmp (long_options[option_index].name, "input-cluster-sizes-file-name") == 0)
          {
            if (local_args_info.input_cluster_sizes_file_name_given)
              {
                fprintf (stderr, "%s: `--input-cluster-sizes-file-name' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->input_cluster_sizes_file_name_given && ! override)
              continue;
            local_args_info.input_cluster_sizes_file_name_given = 1;
            args_info->input_cluster_sizes_file_name_given = 1;
            if (args_info->input_cluster_sizes_file_name_arg)
              free (args_info->input_cluster_sizes_file_name_arg); /* free previous string */
            args_info->input_cluster_sizes_file_name_arg = gengetopt_strdup (optarg);
            if (args_info->input_cluster_sizes_file_name_orig)
              free (args_info->input_cluster_sizes_file_name_orig); /* free previous string */
            args_info->input_cluster_sizes_file_name_orig = gengetopt_strdup (optarg);
          }
          /* End size of each output cluster (cluster size).  */
          else if (strcmp (long_options[option_index].name, "output-cluster-sizes-file-name") == 0)
          {
            if (local_args_info.output_cluster_sizes_file_name_given)
              {
                fprintf (stderr, "%s: `--output-cluster-sizes-file-name' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->output_cluster_sizes_file_name_given && ! override)
              continue;
            local_args_info.output_cluster_sizes_file_name_given = 1;
            args_info->output_cluster_sizes_file_name_given = 1;
            if (args_info->output_cluster_sizes_file_name_arg)
              free (args_info->output_cluster_sizes_file_name_arg); /* free previous string */
            args_info->output_cluster_sizes_file_name_arg = gengetopt_strdup (optarg);
            if (args_info->output_cluster_sizes_file_name_orig)
              free (args_info->output_cluster_sizes_file_name_orig); /* free previous string */
            args_info->output_cluster_sizes_file_name_orig = gengetopt_strdup (optarg);
          }
          /* Allows merging of provably minimal edge intervals, even if the exact merge score (cluster height in dendrogram) is not known at merge time due to partial knowledge implied by the memory constraint. This option allows further clustering per round, thus speeding up the wholse clustering process considerably, by posing a less strict requirement on the output - now the cluster heights are no longer required to be exact. Currently, an upper bound on the merge score is output in this case..  */
          else if (strcmp (long_options[option_index].name, "allow-non-dendrogram") == 0)
          {
            if (local_args_info.allow_non_dendrogram_given)
              {
                fprintf (stderr, "%s: `--allow-non-dendrogram' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->allow_non_dendrogram_given && ! override)
              continue;
            local_args_info.allow_non_dendrogram_given = 1;
            args_info->allow_non_dendrogram_given = 1;
            args_info->allow_non_dendrogram_flag = !(args_info->allow_non_dendrogram_flag);
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
